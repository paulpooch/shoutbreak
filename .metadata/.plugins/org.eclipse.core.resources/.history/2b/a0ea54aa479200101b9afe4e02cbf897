package com.shoutbreak.service;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Set;

import com.shoutbreak.C;

import android.content.Context;
import android.content.SharedPreferences;
import android.provider.Settings;
import android.telephony.TelephonyManager;

// Based on observer pattern. More here: http://www.youtube.com/watch?v=qw0zZAte66A
public class User {
	
	// OBSERVER PATTERN STUFF
	private Set<UserListener> _listeners; // Set prevents duplicates from being entered.
	
	public synchronized void addUserListener(UserListener listener) {
		_listeners.add(listener);
	}

	public synchronized void removeUserListener(UserListener listener) {
		_listeners.remove(listener);
	}
	
	public synchronized void removeAllListeners() {
		_listeners.clear();
	}
	
	protected synchronized void fireUserEvent(int eventType) {
		UserEvent e = new UserEvent(this, eventType);
		for (UserListener listener : _listeners) {
			listener.handleUserEvent(e);
		}
	}
	
	public synchronized int getListenerCount() {
		return _listeners.size();
	}
	
	// All Database stuff should go through User. Any writes should be
	// synchronized.

	// STATICS ////////////////////////////////////////////////////////////////

	public static float calculateRadius(int power, double density) {
		int maxPeople = power * C.CONFIG_PEOPLE_PER_LEVEL;
		double area = maxPeople / density;
		float radius = (float) Math.sqrt(area / Math.PI);
		return radius;
	}
	
	public static int calculatePower(int people) {
		return (int)Math.ceil((float)people / (float)C.CONFIG_PEOPLE_PER_LEVEL);
	}

	public static void setBooleanPreference(Context context, String key, boolean val) {
		SharedPreferences settings = context.getSharedPreferences(C.PREFS_NAMESPACE, Context.MODE_PRIVATE);
		SharedPreferences.Editor editor = settings.edit();
		editor.putBoolean(key, val);
		editor.commit();
	}

	public static boolean getBooleanPreference(Context context, String key, boolean defaultReturnVal) {
		SharedPreferences settings = context.getSharedPreferences(C.PREFS_NAMESPACE, Context.MODE_PRIVATE);
		boolean val = settings.getBoolean(key, defaultReturnVal);
		return val;
	}
	
	// END STATICS ////////////////////////////////////////////////////////////
	
	private ShoutbreakService _service;
	private TelephonyManager _tm;
	private Database _db;
	private CellDensity _cellDensity;
	private LocationTracker _locationTracker;
	protected Inbox _inbox;
	private int _shoutsJustReceived;
	private boolean _levelUpOccured; //This means level up.
	//private boolean _densityJustChanged;
	private boolean _scoresJustReceived;
	private String _uid;
	private String _auth;
	private boolean _passwordExists; // no reason to put actual pw into memory
	private int _level;
	private int _points;
	private int _nextLevelAt;
	
	public User(ShoutbreakService service) {
		_service = service;
		_listeners = new HashSet<UserListener>();
		_tm = (TelephonyManager) service.getSystemService(Context.TELEPHONY_SERVICE);
		_db = new Database(_service);
		_locationTracker = new LocationTracker(_service, this);
		_inbox = new Inbox(_db, this);
		_passwordExists = false;
		_level = 0;
		_points = 0;
		_auth = "default"; // we don't have auth yet... just give us nonce
		HashMap<String, String> userSettings = _db.getUserSettings();
		if (userSettings.containsKey(C.KEY_USER_PW)) {
			_passwordExists = true;
		}
		if (userSettings.containsKey(C.KEY_USER_ID)) {
			_uid = userSettings.get(C.KEY_USER_ID);
		}
		if (userSettings.containsKey(C.KEY_USER_LEVEL)) {
			_level = Integer.parseInt(userSettings.get(C.KEY_USER_LEVEL));
		}
		if (userSettings.containsKey(C.KEY_USER_NEXT_LEVEL_AT)) {
			_nextLevelAt = Integer.parseInt(userSettings.get(C.KEY_USER_NEXT_LEVEL_AT));
		}
		
		_cellDensity = getCellDensity();
		
	}
	
	public synchronized void pullUserInfo() {
		fireUserEvent(UserEvent.LOCATION_SERVICES_CHANGE);
		fireUserEvent(UserEvent.LEVEL_CHANGE);
		fireUserEvent(UserEvent.POINTS_CHANGE);
		fireUserEvent(UserEvent.INBOX_CHANGE);
		fireUserEvent(UserEvent.DENSITY_CHANGE);
	}
	
	public synchronized void saveDensity(double density) {
		CellDensity tempCellDensity = _locationTracker.getCurrentCell();
		_cellDensity.cellX = tempCellDensity.cellX;
		_cellDensity.cellY = tempCellDensity.cellY;
		_cellDensity.density = density;
		_db.saveCellDensity(_cellDensity);
		_cellDensity.isSet = true;
		//setDensityJustChanged(true);
	}
	
	public LocationTracker getLocationTracker() {
		return _locationTracker;
	}
	
	public void setShoutsJustReceived(int i) {
		_shoutsJustReceived = i;
	}
	
	public int getShoutsJustReceived() {
		return _shoutsJustReceived;
	}
	
	public void setLevelUpOccured(boolean b) {
		_levelUpOccured = b;
	}
	
	public boolean getLevelUpOccured() {
		return _levelUpOccured;
	}
	
	public void setScoresJustReceived(boolean b) {
		_scoresJustReceived = b;
	}
	
	public boolean getScoresJustReceived() {
		return _scoresJustReceived;
	}
	
	public double getLatitude() {
		return _locationTracker.getLatitude();
	}

	public double getLongitude() {
		return _locationTracker.getLongitude();
	}

	public Inbox getInbox() {
		return _inbox;
	}

	public synchronized CellDensity getCellDensity() {
		if (_cellDensity == null) {
			_cellDensity = new CellDensity();
		} else {
			// If _cellDensity exists, see if it's still valid.
			CellDensity oldCellDensity = _cellDensity;
			CellDensity tempCellDensity = _locationTracker.getCurrentCell();
			_cellDensity.cellX = tempCellDensity.cellX;
			_cellDensity.cellY = tempCellDensity.cellY;
			if (_cellDensity.isSet && _cellDensity.cellX == oldCellDensity.cellX && _cellDensity.cellY == oldCellDensity.cellY) {
				// We're still in the same cell so return this.
				return _cellDensity;
			}
		}
		// Otherwise we'll see if DB has a cached result. If not, isSet will be false.
		CellDensity tempCellDensity = _db.getDensityAtCell(_cellDensity);
		if (tempCellDensity.isSet) {
			_cellDensity.density = tempCellDensity.density;
			_cellDensity.isSet = true;
		}
		return _cellDensity;
	}

	public String getAuth() {
		return _auth;
	}

	public synchronized void updateAuth(String nonce) {
		String pw = "";
		HashMap<String, String> userSettings = _db.getUserSettings();
		if (userSettings.containsKey(C.KEY_USER_PW)) {
			pw = userSettings.get(C.KEY_USER_PW);
		}
		// $auth = sha1($uid . $pw . $nonce);
		//_auth = Hash.sha1(_uid + pw + nonce);	
		_auth = pw + Hash.sha512(pw + nonce + _uid);		
	}

	public boolean hasAccount() {
		return _passwordExists;
	}

	public synchronized void setPassword(String pw) {
		// TODO: should we encrypt or obfuscate this or something?
		// plaintext in db safe?
		_db.saveUserSetting(C.KEY_USER_PW, pw);
		_passwordExists = true;
	}

	public synchronized void setUID(String uid) {
		_db.saveUserSetting(C.KEY_USER_ID, uid);
		_uid = uid;
	}
	
	public synchronized void setLevel(int level) {
		String sLevel = Integer.toString(level);
		_db.saveUserSetting(C.KEY_USER_LEVEL, sLevel);
		_level = level;
	}
	
	// TODO: implement this for when level changes
	public synchronized void setPoints(int points) {
		//String sPoints = Integer.toString(points);
		//_db.saveUserSetting(C.KEY_USER_POINTS, sPoints);
		_db.savePoints(C.POINTS_SHOUT, amount);
		_points = points;
	}
	
	public synchronized void setNextLevelAt(int nextLevelAt) {
		String sNextLevelAt = Integer.toString(nextLevelAt);
		_db.saveUserSetting(C.KEY_USER_NEXT_LEVEL_AT, sNextLevelAt);
		_nextLevelAt = nextLevelAt;
	}
	
	public String getUID() {
		return _uid;
	}
	
	public int getLevel() {
		return _level;
	}
	
	public synchronized void savePoints(int amount) {
		_db.savePoints(C.POINTS_SHOUT, amount);
		_points += amount;
	}
	
	public int getPoints() {
		return _points;
	}
	
	public int getNextLevelAt() {
		return _nextLevelAt;
	}

	public String getDeviceId() {
		return _tm.getDeviceId();
	}

	public String getPhoneNumber() {
		return _tm.getLine1Number();
	}

	public String getNetworkOperator() {
		return _tm.getNetworkOperatorName();
	}

	public String getAndroidId() {
		return Settings.Secure.getString(_service.getContentResolver(), Settings.Secure.ANDROID_ID);
	}

}